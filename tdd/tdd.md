# Разработка, управляемая тестированием (TDD)
## Определение
Разработка, управляемая тестированием (англ. test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки:
- сначала пишется тест, покрывающий желаемое изменение,
- затем пишется код, который позволит пройти тест,
- и под конец проводится рефакторинг нового кода к соответствующим стандартам.

Обычно TDD подразумевает юнит-тесты для создания кода, хотя его можно применять на любом уровне тестирования.

Эта схема часто также называется **"красный, зеленый, рефакторинг"**, потому что сначала юнит-тест проваливается (красный) – ведь код для него ещё не существует; затем пишется код, чтобы тест прошёл (зеленый); и, наконец, код улучшается и оптимизируется (рефакторинг).

## Практика
Рассмотрим эту технику с акцентом на одну важную ее возможность -- большая ценность TDD заключается в том, что **тесты сами по себе выступают как отличные спецификации**.

На практике действительно оказалось удобно начинать именно с тестов. Для примера была взята идея написать приложение для занятия йогой.
В общих чертах набросываем какие будут сущности и в целом кратко функционал.
Далее описывая функциональность продумываем от самого простого до минимальной сложности, не переусложняя и сохраняя компактность. Описав один класс минимальными тестами, создаем этот класс. Возможно продумываем еще функционал, дополняем тесты и реализуем этот функционал. Потом приступаем к следующему классу, описываем его тестами, реализуем. Осознаем необходимые связи между сущностями, дополняем тесты, реализацию. Рефакторим. Так постепенно и компактно формируется проект. Причем тесты действительно воспринимаются как спецификация проекта.

Есть хороший принцип в этом подходе, который стоит соблюдать:
**код не должен следовать тестам, тесты не должны следовать коду.
И тесты, и код должны следовать дизайну, логической архитектуре**.

В целом можно отметить несколько моментов, которые указывают на то, что этот принцип в некоей мере соблюдается:
- прежде чем приступить к написанию тестов и кода, была продумана общая архитектура и дизайн системы;
- описывая функциональность сначала минимальными тестами, а затем дополняя их и реализуя функционал, мы постепенно следуем логической архитектуре;
- рефакторинг кода также подчиняется общей архитектуре и дизайну. Изменения в коде не делаются произвольно, а направлены на улучшение структуры и читаемости кода, сохраняя при этом его функциональность в соответствии с тестами и общим дизайном системы.

Однако как это выглядит фактически? Пишутся тесты например в классе `UserTest`, описывается функционал, потом этот функционал реализуется в классе `User`. И так для каждой сущности. И это выглядит так, что код следует тестам. Или же тесты следую за кодом в плане того, что сценарии рассматриваются в контексте сущности.

Пример юнит-теста:
```csharp
[TestClass]
public class UserTest
{
    private User user;
    private string login;
    private string password;
    private string newPassword;

    [TestInitialize]
    public void Setup()
    {
        login = "login";
        password = "password";
        newPassword = "newPassword";
        user = new User(login, password);
    }

    // <...>
    [TestMethod]
    public void TestCheckPassword_Successfully()
    {
        // Act & Assert 1
        Assert.IsTrue(user.CheckPassword(password));
        Assert.IsFalse(user.CheckPassword(newPassword));

        // Act & Assert 2
        user.SetPassword(newPassword);

        Assert.IsTrue(user.CheckPassword(newPassword));
        Assert.IsFalse(user.CheckPassword(password));
    }
    // <...>
}
```
Пример реализации:
```csharp
public class User
{
    // <...>
    public bool CheckPassword(string passwordToCheck)
    {
        return Password == HashPassword(passwordToCheck);  // манипуляции с паролем выделены в отдельный метод для обеспечения единого дизайна, правильного смысла, закладываемого дизайном.
    }

    private static string HashPassword(string password)
    {
        byte[] hashedBytes = SHA256.HashData(Encoding.UTF8.GetBytes(password));
        return BitConverter.ToString(hashedBytes).Replace("-", "").ToLower();
    }
    // <...>
}
```

Можно более явно разделить уровни тестирования и кода.
Код будет представлять из себя фактическую реализацию с использованиям парадигм, синтаксиса и семантики языка.
А тестирование же будет конкретно рассматривать сценарии. Например тесты будут писаться в контексте сценария `UserStartKriyaTest`, а не в контексте сущности `User`.

Тогда мы получаем что-то похожее уже на BDD. Получаем более ясное и наглядное описание, смыслы и спецификацию функционала приложения.

Пример структуры юнит-теста:
```csharp
[TestClass]
public class UserStartKriyaTest
{
    private User user;
    private Kriya kriya;
    private Statistic statistic;

    [TestInitialize]
    public void Setup()
    {
        user = new User("login", "password");
        kriya = new();
        statistic = new(user, kriya);
    }
    [TestMethod]
    public void TestSelectKriya()
    {
        // Act
        user.useKriya("kriyaName")
        // Assert
        Assert.AreEqual("kriyaName", user.activeKriya.Name);
    }
    [TestMethod]
    public void TestSelectTimerSet()
    {
        // <...>
    }
    public void TestStartTimerSet()
    {
        // <...>
    }

    // <...>

    public void TestFinishedTimerSet()
    {
        // <...>
    }
    [TestMethod]
    public void TestSaveStatictic()
    {
        // <...>
    }
}
```
В итоге мы получаем более осмысленные и наглядные тесты, которые можно рассматривать как спецификацию.

## Заключение
В этой работе мы постарались рассмотреть методологию разработки, управляемой тестированием (TDD), акцентируя внимание на том, как тесты могут служить не только средством проверки корректности работы кода, но и мощным инструментом для определения спецификаций функционала. Это подход, который не только улучшает качество кода и уменьшает количество ошибок, но и способствует более четкому пониманию требований к проекту.

Ключевые рассмотренные моменты:
1. **Тесты как спецификации**: Идея заключается в том, что тесты в рамках TDD могут выступать в роли спецификаций. Это позволяет разработчикам и заинтересованным сторонам лучше понимать требования к функционалу и ожидаемое поведение системы.

2. **Цикл "красный, зеленый, рефакторинг"**: Этот цикл является основой TDD и помогает поддерживать высокое качество кода, делая процесс разработки более предсказуемым и управляемым.

3. **Следование дизайну и архитектуре**: Важный принцип, который заключается в том, что и тесты, и код должны следовать за дизайном и архитектурой системы, а не друг за другом.

Резюме и выводы:
- **TDD способствует лучшему пониманию проекта**: Начиная разработку с написания тестов, разработчики вынуждены детально продумывать функционал и интерфейсы, что ведет к более глубокому пониманию требований и целей проекта.
- **Улучшение качества кода**: Постоянное использование тестов в процессе разработки помогает обнаруживать и исправлять ошибки на ранних этапах, что снижает стоимость их исправления и улучшает общее качество кода.
- **Рефакторинг как неотъемлемая часть процесса**: Рефакторинг в контексте TDD не является случайным или произвольным. Он направлен на улучшение структуры кода и его читаемости, при этом сохраняя его функциональность, что поддерживается благодаря наличию тестов.
- **Важность дизайна и архитектуры**: как код, так и тесты должны следовать за заранее определенным дизайном и архитектурой системы, что способствует созданию хорошо структурированного и легко поддерживаемого кода.